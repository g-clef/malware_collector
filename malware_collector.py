import asyncio
import configparser
import datetime
import logging

import os
import git

from typing import List, Optional, Tuple


log = logging.getLogger("malware_collector")

class MalwareCollector:
    def __init__(self):
        self.configfile = configparser.ConfigParser()
        self.configfile.read("malware_collector.conf")
        self.archive_prefix = os.environ.get("ARCHIVE_PATH", "/RAID")
        self._cleanup = os.environ.get("CLEANUP", "false").lower() in ("true", "True", 1)
        self.path = None
        self.loop = asyncio.get_event_loop()
        self.repo: Optional[git.Repo] = None


    def pull_from_repo(self, git_path, git_url) -> Tuple[bool, str]:
        """
        perform a git pull on the configured directory. If we had to clone the repo, return true, since changes
        definitely occurred.

        :return: boolean,  whether there were any updates during the git pull
        """
        if not os.path.exists(git_path):
            os.mkdir(git_path)
            git.Repo.clone_from(git_url, git_path)
            self.repo = git.Repo(git_path)
            return True, ""
        else:
            try:
                self.repo = git.Repo(git_path)
            except git.exc.InvalidGitRepositoryError:
                git.Repo.clone_from(git_url, git_path)
                self.repo = git.Repo(git_path)
                return True, ""
        current = self.repo.head.commit
        self.repo.remotes.origin.pull()

        return current != self.repo.head.commit, current

    def get_changed_files_between_pulls(self, first: str) -> List[str]:
        commits = list(self.repo.iter_commits(rev=f"{first}.."))
        changed_files = list()
        for item in commits[0].diff(commits[-1]):
            if item.a_blob.path not in changed_files:
                changed_files.append(item.a_blob.path)

            if item.b_blob is not None and item.b_blob.path not in changed_files:
                changed_files.append(item.b_blob.path)
        return changed_files

    def get(self):
        raise NotImplemented

    def cleanup(self):
        raise NotImplemented

    def make_day_directory(self):
        timestamp = datetime.datetime.now(datetime.timezone.utc)
        daydirname = os.path.join(self.path,
                                  str(timestamp.year),
                                  str(timestamp.month),
                                  str(timestamp.day))
        if not os.path.isdir(daydirname):
            os.makedirs(daydirname)
        return daydirname

    def scan_single_file(self, stoq, metadata, target):
        log.info(f"scanning {target}")
        filehandle = open(target, "rb")
        if "file_path" not in metadata.extra_data or metadata.extra_data['file_path'] != target:
            metadata.extra_data['file_path'] = target
        self.loop.run_until_complete(stoq.scan(content=filehandle.read(), request_meta=metadata))

    def scan_downloaded_files(self, stoq, metadata, files_downloaded):
        for file_path in files_downloaded:
            self.scan_single_file(stoq, metadata, file_path)

    def run(self):
        assert self.path is not None
        if self._cleanup:
            return self.cleanup()
        else:
            return self.get()